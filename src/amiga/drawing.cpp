/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <QSemaphore>
#include <QImage>
#include <QRgb>

#include "amiga.h"
#include "mem.h"
#include "custom.h"
#include "cpu.h"
#include "drawing.h"

#define GFXVIDINFO_WIDTH 320
#define GFXVIDINFO_HEIGHT MAXVPOS
#define VISIBLE_LEFT_BORDER 72
#define VISIBLE_RIGHT_BORDER 392
#define LINETOSCR_X_ADJUST_BYTES VISIBLE_LEFT_BORDER*2

/* Lookup tables for dual playfields.  The dblpf_*1 versions are for the case
   that playfield 1 has the priority, dbplpf_*2 are used if playfield 2 has
   priority.  If we need an array for non-dual playfield mode, it has no number.  */
/* The dbplpf_ms? arrays contain a shift value.  plf_spritemask is initialized
   to contain two 16 bit words, with the appropriate mask if pf1 is in the
   foreground being at bit offset 0, the one used if pf2 is in front being at
   offset 16.  */

static int dblpf_ms1[256], dblpf_ms2[256], dblpf_ms[256];
static int dblpf_ind1[256], dblpf_ind2[256];
static int dblpf_2nd1[256], dblpf_2nd2[256];
static int sprite_offs[256];

/* Video buffer description structure. Filled in by the graphics system
 * dependent code. */

/* OCS/ECS color lookup table. */
uint xcolors[4096];

struct color_entry colors_for_drawing;

union {
	u8 apixels[MAX_PIXELS_PER_LINE * 2];
	u16 apixels_w[MAX_PIXELS_PER_LINE * 2 / 2];
	u32 apixels_l[MAX_PIXELS_PER_LINE * 2 / 4];
} pixdata;

u16 spixels[2 * MAX_SPR_PIXELS];
union sps_union spixstate;

char *xlinebuffer;
static char *row_map[2049];

/* line_draw_funcs: pfield_do_linetoscr, pfield_do_fill_line */
typedef void (*line_draw_func)(int, int);

u8 line_data[(MAXVPOS + 1) * 2][MAX_PLANES * MAX_WORDS_PER_LINE * 2];

/* These are generated by the drawing code from the line_decisions array for
   each line that needs to be drawn.  These are basically extracted out of
   bit fields in the hardware registers.  */
static int bpldualpf, bpldualpfpri, bpldualpf2of, bplplanecnt, bplres;
static u32 plf_sprite_mask;

bool amigaDrawEnabled = true;

static u32 doMask(int p, int bits, int shift) {
	/* p is a value from 0 to 15 (Amiga color value)
	 * scale to 0..255, shift to align msb with mask, and apply mask */
	u32 val = p * 0x11111111UL;
	val >>= (32 - bits);
	val <<= shift;
	return val;
}

static void init_colors() {
	for (int i = 0; i < 4096; i++) {
		int r = (i >> 8) & 0xF;
		int g = (i >> 4) & 0xF;
		int b = (i >> 0) & 0xF;
		u16 c = doMask(r, 5, 11) | doMask(g, 6, 5) | doMask(b, 5, 0);
		xcolors[i] = c | (c << 16);
	}
}

static struct decision *dp_for_drawing;
static struct draw_info *dip_for_drawing;

/*
 * Screen update macros/functions
 */

/* The important positions in the line: where do we start drawing the left border,
   where do we start drawing the playfield, where do we start drawing the right border.
   All of these are forced into the visible window (VISIBLE_LEFT_BORDER .. VISIBLE_RIGHT_BORDER).
   PLAYFIELD_START and PLAYFIELD_END are in window coordinates.  */
static int playfield_start, playfield_end;
static int pixels_offset;
static int src_pixel;
static u8 *real_bplpt[8];

static inline void pfield_do_linetoscr(int dpix, int stoppos) {
	u16 *buf = ((u16 *)xlinebuffer);
	int res = bplres+1;
	if (bpldualpf) {
		/* CASO DUAL */
		// OCS/ECS Dual playfield
		int *lookup = bpldualpfpri ? dblpf_ind2 : dblpf_ind1;
		while (dpix < stoppos) {
			u16 d = colors_for_drawing.acolors[lookup[pixdata.apixels[src_pixel]]];
			buf[dpix++] = d;
			src_pixel += res;
		}
	} else {
		/* CASO NORMAL */
		while (dpix < stoppos) {
			buf[dpix++]= (colors_for_drawing.acolors[pixdata.apixels[src_pixel]]);
			src_pixel += res;
		}
	}
}

static void pfield_do_fill_line(int start, int stop) {
	u16 *b = &(((u16 *)xlinebuffer)[start]);
	uint col = colors_for_drawing.acolors[0];
	int max = stop - start;
	for (int i = 0; i < max; i++,b++)
		*b = col;
}

/* Initialize the variables necessary for drawing a line.
 * This involves setting up start/stop positions and display window
 * borders.  */
static void pfield_init_linetoscr() {
	/* First, get data fetch start/stop in DIW coordinates.  */
	int ddf_left = (dp_for_drawing->plfleft << 1) + DIW_DDF_OFFSET;
	int ddf_right = (dp_for_drawing->plfright << 1) + DIW_DDF_OFFSET;
	/* Compute datafetch start/stop in pixels; native display coordinates.  */
	int native_ddf_left = coord_hw_to_window_x(ddf_left);
	int native_ddf_right = coord_hw_to_window_x(ddf_right);

	int linetoscr_diw_start = dp_for_drawing->diwfirstword;
	int linetoscr_diw_end = dp_for_drawing->diwlastword;

	if (dip_for_drawing->nr_sprites == 0) {
		if (linetoscr_diw_start < native_ddf_left)
			linetoscr_diw_start = native_ddf_left;
		if (linetoscr_diw_end > native_ddf_right)
			linetoscr_diw_end = native_ddf_right;
	}

	/* Perverse cases happen. */
	if (linetoscr_diw_end < linetoscr_diw_start)
		linetoscr_diw_end = linetoscr_diw_start;

	playfield_start = qBound(VISIBLE_LEFT_BORDER, linetoscr_diw_start, VISIBLE_RIGHT_BORDER);
	playfield_end = qBound(VISIBLE_LEFT_BORDER, linetoscr_diw_end, VISIBLE_RIGHT_BORDER);

	/* Now, compute some offsets.  */

	ddf_left -= DISPLAY_LEFT_SHIFT;
	ddf_left <<= bplres;
	pixels_offset = MAX_PIXELS_PER_LINE - ddf_left;

	int unpainted = VISIBLE_LEFT_BORDER < playfield_start ? 0 : VISIBLE_LEFT_BORDER - playfield_start;
	src_pixel = MAX_PIXELS_PER_LINE + (playfield_start - native_ddf_left + unpainted);

	if (dip_for_drawing->nr_sprites == 0)
		return;
	/* Must clear parts of apixels.  */
	if (linetoscr_diw_start < native_ddf_left) {
		int size = native_ddf_left - linetoscr_diw_start;
		linetoscr_diw_start = native_ddf_left;
		bzero(pixdata.apixels + MAX_PIXELS_PER_LINE - size, size);
	}
	if (linetoscr_diw_end > native_ddf_right) {
		int pos = native_ddf_right - native_ddf_left;
		int size = linetoscr_diw_end - native_ddf_right;
		linetoscr_diw_start = native_ddf_left;
		bzero(pixdata.apixels + MAX_PIXELS_PER_LINE + pos, size);
	}
}


static inline void fill_line() {
	u32 *start = (u32 *)((u8 *)xlinebuffer + (VISIBLE_LEFT_BORDER << 1));
	u32 val = colors_for_drawing.acolors[0];
	val |= val << 16;

	for (uint nints = GFXVIDINFO_WIDTH /2; nints > 0; nints -= 8) {
		*start = val;
		*(start+1) = val;
		*(start+2) = val;
		*(start+3) = val;
		*(start+4) = val;
		*(start+5) = val;
		*(start+6) = val;
		*(start+7) = val;
		start += 8;
	}
}

static inline void gen_pfield_tables() {
	/* For now, the AJA stuff is broken in the dual playfield case. We encode
	 * sprites in dpf mode by ORing the pixel value with 0x80. To make dual
	 * playfield rendering easy, the lookup tables contain are made linear for
	 * values >= 128. That only works for OCS/ECS, though. */

	for (int i = 0; i < 256; i++) {
		int plane1 = (i & 1) | ((i >> 1) & 2) | ((i >> 2) & 4) | ((i >> 3) & 8);
		int plane2 = ((i >> 1) & 1) | ((i >> 2) & 2) | ((i >> 3) & 4) | ((i >> 4) & 8);

		dblpf_2nd1[i] = plane1 == 0 ? (plane2 == 0 ? 0 : 2) : 1;
		dblpf_2nd2[i] = plane2 == 0 ? (plane1 == 0 ? 0 : 1) : 2;

		dblpf_ms1[i] = plane1 == 0 ? (plane2 == 0 ? 16 : 8) : 0;
		dblpf_ms2[i] = plane2 == 0 ? (plane1 == 0 ? 16 : 0) : 8;
		dblpf_ms[i] = i == 0 ? 16 : 8;
		if (plane2 > 0)
			plane2 += 8;
		dblpf_ind1[i] = i >= 128 ? i & 0x7F : (plane1 == 0 ? plane2 : plane1);
		dblpf_ind2[i] = i >= 128 ? i & 0x7F : (plane2 == 0 ? plane1 : plane2);

		sprite_offs[i] = (i & 15) ? 0 : 2;
	}
}

static inline void draw_sprites_1(struct sprite_entry *_GCCRES_ e, int dualpf,
				   int doubling, int has_attach) {
	int *shift_lookup = dualpf ? (bpldualpfpri ? dblpf_ms2 : dblpf_ms1) : dblpf_ms;
	u16 *buf = spixels + e->first_pixel;
	u8 *stbuf = spixstate.bytes + e->first_pixel;

	buf -= e->pos;
	stbuf -= e->pos;

	int window_pos = e->pos + ((DIW_DDF_OFFSET - DISPLAY_LEFT_SHIFT) );
	if (doubling)
		window_pos <<= 1;
	window_pos += pixels_offset;
	for (int pos = e->pos; pos < e->max; pos += 1) {
		int maskshift, plfmask;
		uint v = buf[pos];

		maskshift = shift_lookup[pixdata.apixels[window_pos]];
		plfmask = (plf_sprite_mask >> maskshift) >> maskshift;
		v &= ~plfmask;
		if (v != 0) {
			uint vlo, vhi, col;
			uint v1 = v & 255;
			int offs;
			if (v1 == 0)
				offs = 4 + sprite_offs[v >> 8];
			else
				offs = sprite_offs[v1];

			v >>= offs << 1;
			v &= 15;

			if (has_attach && (stbuf[pos] & (1 << offs))) {
				col = v;
				col += 16;
			} else {
				vlo = v & 3;
				vhi = (v & (vlo - 1)) >> 2;
				col = (vlo | vhi);
				col += 16;
				col += (offs << 1);
			}
			if (dualpf) {
				col += 128;
				if (doubling)
					pixdata.apixels_w[window_pos >> 1] = col | (col << 8);
				else
					pixdata.apixels[window_pos] = col;
			} else {
				if (doubling)
					pixdata.apixels_w[window_pos >> 1] = col | (col << 8);
				else
					pixdata.apixels[window_pos] = col;
			}
		}
		window_pos += 1 << doubling;
	}
}

#define draw_sprites_normal_sp_lo_nat(ENTRY) draw_sprites_1	(ENTRY, 0, 0, 0)
#define draw_sprites_normal_dp_lo_nat(ENTRY) draw_sprites_1	(ENTRY, 1, 0, 0)
#define draw_sprites_normal_sp_lo_at(ENTRY)  draw_sprites_1	(ENTRY, 0, 0, 1)
#define draw_sprites_normal_dp_lo_at(ENTRY)  draw_sprites_1	(ENTRY, 1, 0, 1)
#define draw_sprites_normal_sp_hi_nat(ENTRY) draw_sprites_1	(ENTRY, 0, 1, 0)
#define draw_sprites_normal_dp_hi_nat(ENTRY) draw_sprites_1	(ENTRY, 1, 1, 0)
#define draw_sprites_normal_sp_hi_at(ENTRY)  draw_sprites_1	(ENTRY, 0, 1, 1)
#define draw_sprites_normal_dp_hi_at(ENTRY)  draw_sprites_1	(ENTRY, 1, 1, 1)

static inline void draw_sprites_ecs(struct sprite_entry *_GCCRES_ e) {
	if (e->has_attached) {
		if (bplres == 1) {
			if (bpldualpf)
				draw_sprites_normal_dp_hi_at (e);
			else
				draw_sprites_normal_sp_hi_at (e);
		} else {
			if (bpldualpf)
				draw_sprites_normal_dp_lo_at (e);
			else
				draw_sprites_normal_sp_lo_at (e);
		}
	} else {
		if (bplres == 1) {
			if (bpldualpf)
				draw_sprites_normal_dp_hi_nat (e);
			else
				draw_sprites_normal_sp_hi_nat (e);
		} else {
			if (bpldualpf)
				draw_sprites_normal_dp_lo_nat (e);
			else
				draw_sprites_normal_sp_lo_nat (e);
		}
	}
}

#define MERGE(a,b,mask,shift) {\
	register u32 tmp = mask & (a ^ (b >> shift)); \
	a ^= tmp; \
	b ^= (tmp << shift); \
}

#define MERGE_0(a,b,mask,shift) {\
   register u32 tmp = mask & (b>>shift); \
   a = tmp; \
   b ^= (tmp << shift); \
}

#define GETLONG(P) (*(u32 *)P)
#define DATA_POINTER(n) (line_data[lineno] + (n)*MAX_WORDS_PER_LINE*2)

#define DO_SWLONG(A,V) {\
	register u8 *b = (u8 *)(A); \
	register u32 v = (V); \
	*b++ = v >> 24; \
	*b++ = v >> 16; \
	*b++ = v >> 8; \
	*b = v; \
}

static inline void pfield_doline_1 (u32 *_GCCRES_ pixels, int wordcount, int planes) {
	while (wordcount-- > 0) {
		u32 b0, b1, b2, b3, b4, b5, b6, b7;

		b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0, b7 = 0;
		switch (planes) {
		case 8: b0 = GETLONG ((u32 *)real_bplpt[7]); real_bplpt[7] += 4;
		case 7: b1 = GETLONG ((u32 *)real_bplpt[6]); real_bplpt[6] += 4;
		case 6: b2 = GETLONG ((u32 *)real_bplpt[5]); real_bplpt[5] += 4;
		case 5: b3 = GETLONG ((u32 *)real_bplpt[4]); real_bplpt[4] += 4;
		case 4: b4 = GETLONG ((u32 *)real_bplpt[3]); real_bplpt[3] += 4;
		case 3: b5 = GETLONG ((u32 *)real_bplpt[2]); real_bplpt[2] += 4;
		case 2: b6 = GETLONG ((u32 *)real_bplpt[1]); real_bplpt[1] += 4;
		case 1: b7 = GETLONG ((u32 *)real_bplpt[0]); real_bplpt[0] += 4;
		}

		MERGE (b0, b1, 0x55555555, 1);
		MERGE (b2, b3, 0x55555555, 1);
		MERGE (b4, b5, 0x55555555, 1);
		MERGE (b6, b7, 0x55555555, 1);

		MERGE (b0, b2, 0x33333333, 2);
		MERGE (b1, b3, 0x33333333, 2);
		MERGE (b4, b6, 0x33333333, 2);
		MERGE (b5, b7, 0x33333333, 2);

		MERGE (b0, b4, 0x0f0f0f0f, 4);
		MERGE (b1, b5, 0x0f0f0f0f, 4);
		MERGE (b2, b6, 0x0f0f0f0f, 4);
		MERGE (b3, b7, 0x0f0f0f0f, 4);

		MERGE (b0, b1, 0x00ff00ff, 8);
		MERGE (b2, b3, 0x00ff00ff, 8);
		MERGE (b4, b5, 0x00ff00ff, 8);
		MERGE (b6, b7, 0x00ff00ff, 8);

		MERGE (b0, b2, 0x0000ffff, 16);
		DO_SWLONG(pixels, b0);
		DO_SWLONG(pixels + 4, b2);
		MERGE (b1, b3, 0x0000ffff, 16);
		DO_SWLONG(pixels + 2, b1);
		DO_SWLONG(pixels + 6, b3);
		MERGE (b4, b6, 0x0000ffff, 16);
		DO_SWLONG(pixels + 1, b4);
		DO_SWLONG(pixels + 5, b6);
		MERGE (b5, b7, 0x0000ffff, 16);
		DO_SWLONG(pixels + 3, b5);
		DO_SWLONG(pixels + 7, b7);
		pixels += 8;
	}
}

static void pfield_doline(int lineno) {
	int wordcount = dp_for_drawing->plflinelen;
	u32 *data = pixdata.apixels_l + MAX_PIXELS_PER_LINE/4;

	for (int i = 0; i < 8; i++)
		real_bplpt[i] = DATA_POINTER(i);

	switch (bplplanecnt) {
	default: break;
	case 0: bzero(data, wordcount << 5); break;
	case 1: pfield_doline_1(data, wordcount, 1); break;
	case 2: pfield_doline_1(data, wordcount, 2); break;
	case 3: pfield_doline_1(data, wordcount, 3); break;
	case 4: pfield_doline_1(data, wordcount, 4); break;
	case 5: pfield_doline_1(data, wordcount, 5); break;
	case 6: pfield_doline_1(data, wordcount, 6); break;
	case 7: pfield_doline_1(data, wordcount, 7); break;
	case 8: pfield_doline_1(data, wordcount, 8); break;
	}
}

static int drawing_color_matches;
static enum { color_match_acolors, color_match_full } color_match_type;

/* Set up colors_for_drawing to the state at the beginning of the currently drawn
   line.  Try to avoid copying color tables around whenever possible.  */
static inline void adjust_drawing_colors(int ctable) {
	if (drawing_color_matches != ctable) {
		memcpy(colors_for_drawing.acolors, curr_color_tables[ctable].acolors,
			   sizeof(colors_for_drawing.acolors));
		color_match_type = color_match_acolors;
		drawing_color_matches = ctable;
	}
}

static inline void do_color_changes(line_draw_func worker_border, line_draw_func worker_pfield) {
	int lastpos = VISIBLE_LEFT_BORDER;
	for (int i = dip_for_drawing->first_color_change; i <= dip_for_drawing->last_color_change; i++) {
		int regno = curr_color_changes[i].regno;
		uint value = curr_color_changes[i].value;
		int nextpos;
		if (i == dip_for_drawing->last_color_change)
			nextpos = max_diwlastword;
		else
			nextpos = coord_hw_to_window_x (curr_color_changes[i].linepos << 1);

		int nextpos_in_range = nextpos;
		if (nextpos > VISIBLE_RIGHT_BORDER)
			nextpos_in_range = VISIBLE_RIGHT_BORDER;

		if (nextpos_in_range > lastpos) {
			if (lastpos < playfield_start) {
				int t = nextpos_in_range <= playfield_start ? nextpos_in_range : playfield_start;
				(*worker_border) (lastpos, t);
				lastpos = t;
			}
		}
		if (nextpos_in_range > lastpos) {
			if (lastpos >= playfield_start && lastpos < playfield_end) {
				int t = nextpos_in_range <= playfield_end ? nextpos_in_range : playfield_end;
				(*worker_pfield) (lastpos, t);
				lastpos = t;
			}
		}
		if (nextpos_in_range > lastpos) {
			if (lastpos >= playfield_end)
				(*worker_border) (lastpos, nextpos_in_range);
			lastpos = nextpos_in_range;
		}
		if (i != dip_for_drawing->last_color_change) {
			if (regno != -1) {
				color_reg_set(&colors_for_drawing, regno, value);
				colors_for_drawing.acolors[regno] = xcolors[value];
			}
		}
		if (lastpos >= VISIBLE_RIGHT_BORDER)
			break;
	}
}

/* We only save hardware registers during the hardware frame. Now, when
 * drawing the frame, we expand the data into a slightly more useful
 * form. */
static inline void pfield_expand_dp_bplcon() {
	int plf1pri, plf2pri;
	bplres = dp_for_drawing->bplres;
	bplplanecnt = dp_for_drawing->nr_planes;

	plf1pri = dp_for_drawing->bplcon2 & 7;
	plf2pri = (dp_for_drawing->bplcon2 >> 3) & 7;
	plf_sprite_mask = 0xFFFF0000 << (4 * plf2pri);
	plf_sprite_mask |= (0xFFFF << (4 * plf1pri)) & 0xFFFF;
	bpldualpf = (dp_for_drawing->bplcon0 & 0x400) == 0x400;
	bpldualpfpri = (dp_for_drawing->bplcon2 & 0x40) == 0x40;
	bpldualpf2of = (dp_for_drawing->bplcon3 >> 10) & 7;
}

static inline void pfield_draw_line(int lineno) {
	int border = 0;

	dp_for_drawing = line_decisions + lineno;
	dip_for_drawing = curr_drawinfo + lineno;
	if (dp_for_drawing->plfleft == -1)
		border = 1;

	xlinebuffer = row_map[lineno];
	xlinebuffer -= LINETOSCR_X_ADJUST_BYTES;

	if (!border) {
		pfield_expand_dp_bplcon();
		pfield_init_linetoscr();
		pfield_doline(lineno);
		adjust_drawing_colors (dp_for_drawing->ctable);

		for (int i = 0; i < dip_for_drawing->nr_sprites; i++)
			draw_sprites_ecs(curr_sprite_entries + dip_for_drawing->first_sprite_entry + i);
		do_color_changes(pfield_do_fill_line, pfield_do_linetoscr);
	} else {
		adjust_drawing_colors(dp_for_drawing->ctable);
		if (dip_for_drawing->nr_color_changes == 0) {
			fill_line();
			return;
		}
		playfield_start = VISIBLE_RIGHT_BORDER;
		playfield_end = VISIBLE_RIGHT_BORDER;
		do_color_changes(pfield_do_fill_line, pfield_do_fill_line);
	}
}

static void init_drawing_frame() {
	init_hardware_for_drawing_frame();
	drawing_color_matches = -1;
}

extern QSemaphore frameConsSem;
extern QSemaphore frameProdSem;

static void finish_drawing_frame() {
	int maxYPos = (maxvpos - minfirstline);
	for (int i = 0; i < maxYPos; i++)
		pfield_draw_line(i + minfirstline);
}

void AmigaEmu::vSync() {
	if (amigaDrawEnabled)
		finish_drawing_frame();
	init_drawing_frame();

	frameConsSem.release();
	frameProdSem.acquire();
}

void amigaDrawInit(char *frameBits, int framePitch) {
	init_colors();
	xlinebuffer = frameBits;
	for (int i = 0; i < GFXVIDINFO_HEIGHT + 1; i++)
		row_map[i] = frameBits + framePitch * i;
	bzero(spixels, sizeof(spixels));
	bzero(&spixstate, sizeof(spixstate));
	init_drawing_frame();
	gen_pfield_tables();
}
