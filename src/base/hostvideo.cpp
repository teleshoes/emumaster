/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include "hostvideo.h"
#include "emu.h"
#include "emuthread.h"
#include "pathmanager.h"
#include "hostinput.h"
#include "configuration.h"
#include <QPainter>
#include <QKeyEvent>

/*!
	\class HostVideo
	HostVideo class displays frames generated by the emulation and buttons
	provided by HostInput.
 */

/*!
	Creates a new object of HostVideo. The given \a thread requests \a emu
	to generate frames, which in turn are passed to HostVideo to render on
	screen. Above the frame buttons are rendered by the given \a hostInput.
 */
HostVideo::HostVideo(HostInput *hostInput,
					 Emu *emu,
					 EmuThread *thread,
					 QWidget *parent) :
	QGLWidget(parent),
	m_hostInput(hostInput),
	m_emu(emu),
	m_thread(thread)
{
	setAttribute(Qt::WA_NoSystemBackground);
	setAttribute(Qt::WA_AcceptTouchEvents);
	setAttribute(Qt::WA_QuitOnClose, false);
	setAutoFillBackground(false);

	m_fpsVisible = emConf.defaultValue("fpsVisible").toInt();
	m_fpsCount = 0;
	m_fpsCounter = 0;
	m_fpsCounterTime.start();

	m_keepAspectRatio = emConf.defaultValue("keepAspectRatio").toBool();;
	m_bilinearFiltering = emConf.defaultValue("bilinearFiltering").toBool();;

	QObject::connect(m_emu, SIGNAL(videoSrcRectChanged()), SLOT(updateRects()));
}

HostVideo::~HostVideo()
{
}

/*! \internal */
void HostVideo::paintEvent(QPaintEvent *)
{
	QPainter painter;
	painter.begin(this);

	// clear screen early only when we are not drawing on entire screen later
	if (m_keepAspectRatio)
		painter.fillRect(rect(), Qt::black);

	if (m_thread->m_inFrameGenerated) {
		// set bilinear if requested
		if (m_bilinearFiltering)
			painter.setRenderHint(QPainter::SmoothPixmapTransform);
		// draw frame
		painter.drawImage(m_dstRect, m_emu->frame(), m_srcRect);
		// draw fps if requested
		if (m_fpsVisible)
			paintFps(&painter);
	} else if (!m_keepAspectRatio) {
		painter.fillRect(rect(), Qt::black);
	}
	// draw buttons
	m_hostInput->paint(&painter);
	painter.end();
}

/*! \internal */
void HostVideo::paintFps(QPainter *painter)
{
	// calculate fps
	m_fpsCounter++;
	if (m_fpsCounterTime.elapsed() >= 1000) {
		m_fpsCount = m_fpsCounter;
		m_fpsCounter = 0;
		m_fpsCounterTime.restart();
	}
	// set font and draw fps
	QFont font = painter->font();
	font.setPointSize(12);
	painter->setFont(font);
	painter->setPen(Qt::red);
	painter->drawText(QRectF(80.0f, 0.0f, 100.0f, 60.0f),
					  Qt::AlignCenter,
					  QString("%1 FPS").arg(m_fpsCount));
}

/*! Sets if fps should be drawn (\a on=true) or not. */
void HostVideo::setFpsVisible(bool on)
{
	m_fpsVisible = on;
}

/*! \internal */
void HostVideo::updateRects()
{
	// update rects if size of source rect changes
	m_srcRect = m_emu->videoSrcRect();
	Q_ASSERT_X(m_srcRect.width() != 0.0f && m_srcRect.height() != 0.0f, "HostVideo", "Define source rect!");
	qreal ww = Width;
	qreal wh = Height;
	if (m_keepAspectRatio) {
		// calculate proportionally scaled rect
		qreal scale = qMin(ww/m_srcRect.width(), wh/m_srcRect.height());
		qreal w = m_srcRect.width() * scale;
		qreal h = m_srcRect.height() * scale;
		qreal x = ww/2.0f-w/2.0f;
		qreal y = wh/2.0f-h/2.0f;
		m_dstRect = QRectF(x, y, w, h);
	} else {
		// take screen size
		m_dstRect = QRectF(QPointF(), QSizeF(ww, wh));
	}
}

/*!
	Sets if aspect ratio must be kept (\a on = true) or frame
	can be displayed on fullscreen.
*/
void HostVideo::setKeepAspectRatio(bool on)
{
	m_keepAspectRatio = on;
	if (m_srcRect.width() != 0.0f)
		updateRects();
}

/*! Enables/disables bilinear filtering. */
void HostVideo::setBilinearFiltering(bool enabled)
{
	m_bilinearFiltering = enabled;
}
